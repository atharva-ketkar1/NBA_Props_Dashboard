import pandas as pd
import requests
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import os
import io
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# --- CONFIGURATION ---
# Path to the file generated by your 'season_stats_scrape.py'
#STATS_FILE = '../data/current/season_stats.csv'
STATS_FILE = os.path.join(os.path.dirname(__file__), '../data/current/season_stats.csv')

# Visual Settings (Updated to match PropsMadness style)
ZONE_COLORS = {
    'High': '#a3c76c',   # Green (High Frequency)
    'Med':  '#e09f53',   # Tan/Orange (Medium Frequency)
    'Low':  '#f2d875'    # Yellow (Low Frequency)
}

def get_team_id_for_player(player_name):
    """
    Loads local season stats to find the Team ID for a given player.
    """
    if not os.path.exists(STATS_FILE):
        print(f"⚠️ Stats file not found at {STATS_FILE}. Run season_stats_scrape.py first.")
        return None

    try:
        df = pd.read_csv(STATS_FILE)
        # Normalize for matching
        player_clean = player_name.lower().strip()
        df['player_lower'] = df['PLAYER_NAME'].str.lower().str.strip()
        
        match = df[df['player_lower'] == player_clean]
        
        if not match.empty:
            return str(match.iloc[0]['TEAM_ID'])
        else:
            print(f"❌ Player '{player_name}' not found in season_stats.csv.")
            return None
    except Exception as e:
        print(f"Error reading stats file: {e}")
        return None

def fetch_assist_data(player_name, team_id, season="2025-26"):
    # UPDATE: We use the 'totals' endpoint if networks fails, or try networks with better headers
    url = "https://api.pbpstats.com/get-assist-networks/nba"
    
    params = {
        "Season": season,
        "SeasonType": "Regular Season",
        "EntityId": team_id,
        "EntityType": "Team"
    }
    
    # --- KEY FIX: BROWSER HEADERS ---
    # These headers make the request look like it's coming from the pbpstats.com website
    headers = {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Referer": "https://www.pbpstats.com/",
        "Origin": "https://www.pbpstats.com",
        "Accept": "application/json, text/plain, */*",
        "Connection": "keep-alive"
    }

    session = requests.Session()
    retry = Retry(connect=3, read=3, redirect=3, backoff_factor=1, status_forcelist=[500, 502, 503, 504])
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('https://', adapter)

    try:
        print(f"Fetching data from PBPStats (Attempting to bypass 502)...")
        # Timeout increased to 45s, though server may cut it off sooner
        response = session.get(url, params=params, headers=headers, timeout=45)
        response.raise_for_status()
        
        data = response.json()
        
        # ... (Rest of your parsing logic remains exactly the same) ...
        node_map = {node['id']: node['name'] for node in data['results']['nodes']}
        player_stats = {'Rim': 0, 'Mid': 0, 'Corner3': 0, 'Arc3': 0, 'Total': 0}
        found = False
        
        for link in data['results']['links']:
            source_id = link['source']
            source_name = node_map.get(source_id, str(source_id))
            
            if player_name.lower() in source_name.lower():
                found = True
                # "Rim" = Restricted Area
                rim_val = link.get('AtRim', 0)
                # "Mid" = ShortMidRange (Floaters) + LongMidRange
                mid_val = link.get('ShortMidRange', 0) + link.get('LongMidRange', 0)
                
                player_stats['Rim'] += rim_val
                player_stats['Mid'] += mid_val
                player_stats['Corner3'] += link.get('Corner3', 0)
                player_stats['Arc3'] += link.get('Arc3', 0)
                player_stats['Total'] += link.get('value', 0)
        
        if not found:
            print(f"Player '{player_name}' found in team data, but had 0 assists recorded.")
            return None

        return player_stats

    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 502:
            print("\n❌ API Error: 502 Bad Gateway.")
            print("The PBPStats server is currently overloaded and cannot calculate the full team network.")
            print("Recommendation: Use the 'pbpstats' Python library to calculate this locally instead of via API.")
        else:
            print(f"❌ HTTP Error: {e}")
        return None
    except Exception as e:
        print(f"❌ Error: {e}")
        return None

    except requests.exceptions.ReadTimeout:
        print("❌ Error: The PBPStats API took too long to respond. Try running the script again later.")
        return None
    except Exception as e:
        print(f"❌ Error fetching PBPStats: {e}")
        return None

    except Exception as e:
        print(f"Error fetching PBPStats: {e}")
        return None

def get_color(pct):
    """Returns color based on frequency percentage."""
    if pct >= 0.30: return ZONE_COLORS['High']
    if pct >= 0.10: return ZONE_COLORS['Med']
    return ZONE_COLORS['Low']

def plot_assist_zones(player_name, stats, save_path=None):
    """
    Generates the PropsMadness-style visual.
    Assumes 'stats' contains: {'Rim', 'Mid', 'Corner3', 'Arc3', 'Total'}
    """
    # 1. Calculate percentages
    total = stats['Total']
    if total == 0:
        print("Cannot plot: Total assists is 0.")
        return None

    # Calculate raw percentages for coloring
    pcts = {k: v / total for k, v in stats.items() if k != 'Total'}
    
    # 2. Setup Figure
    fig, ax = plt.subplots(figsize=(10, 8))
    ax.set_facecolor('black')
    fig.patch.set_facecolor('black')
    
    # 3. DRAWING ZONES (Painter's Algorithm: Back to Front)
    
    # --- ARC 3 (The Background) ---
    # Covers the entire top area.
    ax.add_patch(patches.Rectangle((-25, 0), 50, 47, 
                                   facecolor=get_color(pcts['Arc3']), 
                                   edgecolor='black', lw=2))

    # --- MIDRANGE (Large Semi-Circle) ---
    # Radius ~28ft covers the standard midrange area.
    ax.add_patch(patches.Wedge((0, 0), 28, 0, 180, 
                               facecolor=get_color(pcts['Mid']), 
                               edgecolor='black', lw=2))

    # --- CORNER 3s (Vertical Rectangles) ---
    # These "cut" into the sides of the midrange arc.
    # We color these based on the TOTAL Corner frequency (or you can split if you prefer)
    c_color = get_color(pcts['Corner3'])
    
    # Left Corner
    ax.add_patch(patches.Rectangle((-25, 0), 3, 14, facecolor=c_color, edgecolor='black', lw=2))
    # Right Corner
    ax.add_patch(patches.Rectangle((22, 0), 3, 14, facecolor=c_color, edgecolor='black', lw=2))

    # --- RIM (Small Semi-Circle) ---
    # Radius ~9ft (Restricted Area + small buffer).
    ax.add_patch(patches.Wedge((0, 0), 9, 0, 180, 
                               facecolor=get_color(pcts['Rim']), 
                               edgecolor='black', lw=2))

    # 4. LABELS
    def add_label(x, y, text_val):
        """Helper to add the white-box labels"""
        # White box, black text, rounded edges
        ax.text(x, y, text_val, ha='center', va='center', 
                fontsize=14, fontweight='bold', color='black',
                bbox=dict(facecolor='white', edgecolor='none', 
                          boxstyle='round,pad=0.2', alpha=1.0))

    # Helper to format percentage string
    def fmt_pct(val):
        return f"{int(round(val*100))}%"

    # -- Rim Label --
    add_label(0, 4.5, fmt_pct(pcts['Rim']))

    # -- Mid Label --
    add_label(0, 18, fmt_pct(pcts['Mid']))

    # -- Arc 3 Label --
    add_label(0, 35, fmt_pct(pcts['Arc3']))

    # -- Corner 3 Labels (SPLIT LOGIC) --
    # The API gives us the TOTAL frequency of corner assists.
    # Visually, we want to show half on the left and half on the right.
    corner_split_val = pcts['Corner3'] / 2
    corner_text = fmt_pct(corner_split_val)
    
    add_label(-23.5, 7, corner_text)  # Left Corner
    add_label(23.5, 7, corner_text)   # Right Corner

    # 5. TITLE & CLEANUP
    ax.set_title(f"Assisting Zones: {player_name}", color='white', fontsize=18, pad=15)
    
    # Set limits to frame the court correctly
    ax.set_xlim(-25, 25)
    ax.set_ylim(0, 40) # Cut off the very top to match aspect ratio
    ax.axis('off')
    
    if save_path:
        plt.savefig(save_path, bbox_inches='tight', facecolor='black')
        print(f"Chart saved to {save_path}")
        plt.close()
    else:
        return fig

# --- MAIN FUNCTION FOR DASHBOARD ---
def generate_assist_chart(player_name):
    """
    Orchestrator function:
    1. Finds Team ID
    2. Fetches Data
    3. Returns Figure (or None if failed)
    """
    print(f"Generating Assist Chart for {player_name}...")
    
    # 1. Get Team ID
    team_id = get_team_id_for_player(player_name)
    if not team_id:
        return None
        
    # 2. Fetch Data
    stats = fetch_assist_data(player_name, team_id)
    if not stats:
        print(f"No assist data found for {player_name}")
        return None
        
    # 3. Plot
    return plot_assist_zones(player_name, stats)

# --- EXAMPLE USAGE ---
if __name__ == "__main__":
    # Ensure this matches a player in your season_stats.csv
    player = "Victor Wembanyama" 
    
    fig = generate_assist_chart(player)
    
    if fig:
        plt.show()